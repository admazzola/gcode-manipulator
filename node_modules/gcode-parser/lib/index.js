'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseStringSync = exports.parseString = exports.parseFileSync = exports.parseFile = exports.parseStream = exports.parseLine = exports.GCodeLineStream = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _timers = require('timers');

var _timers2 = _interopRequireDefault(_timers);

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var noop = function noop() {};

var streamify = function streamify(text) {
    var s = new _stream2.default.Readable();
    s.push(text);
    s.push(null);
    return s;
};

var containsLineEnd = function () {
    var re = new RegExp(/.*(?:\r\n|\r|\n)/g);

    return function (s) {
        return !!s.match(re);
    };
}();

// @param {array} arr The array to iterate over.
// @param {object} opts The options object.
// @param {function} iteratee The iteratee invoked per element.
// @param {function} done The done invoked after the loop has finished.
var iterateArray = function iterateArray() {
    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var iteratee = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;
    var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;

    if (typeof opts === 'function') {
        done = iteratee;
        iteratee = opts;
        opts = {};
    }

    opts.batchSize = opts.batchSize || 1;

    var loop = function loop() {
        var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        for (var count = 0; i < arr.length && count < opts.batchSize; ++i, ++count) {
            iteratee(arr[i], i, arr);
        }
        if (i < arr.length) {
            _timers2.default.setImmediate(function () {
                return loop(i);
            });
            return;
        }
        done();
    };
    loop();
};

// @param {string} line The G-code line
var parseLine = function () {
    // http://reprap.org/wiki/G-code#Special_fields
    // The checksum "cs" for a GCode string "cmd" (including its line number) is computed
    // by exor-ing the bytes in the string up to and not including the * character.
    var computeChecksum = function computeChecksum(s) {
        s = s || '';
        if (s.lastIndexOf('*') >= 0) {
            s = s.substr(0, s.lastIndexOf('*'));
        }

        var cs = 0;
        for (var i = 0; i < s.length; ++i) {
            var c = s[i].charCodeAt(0);
            cs = cs ^ c;
        }
        return cs;
    };
    var stripComments = function () {
        var re1 = new RegExp(/\s*[%#;].*/g); // Strip everything after %, #, or ; to the end of the line, including preceding spaces
        var re2 = new RegExp(/\s*\([^\)]*\)/g); // Remove anything inside the parentheses
        var re3 = new RegExp(/\s+/g);
        return function (line) {
            return line.replace(re1, '').replace(re2, '').replace(re3, '');
        };
    }();
    var re = /([a-zA-Z][0-9\+\-\.]*)|(\*[0-9]+)|(\$[a-zA-Z0-9$#]*)/igm;

    return function (line, options) {
        options = options || {};
        options.noParseLine = options.noParseLine || false;

        var result = {
            line: line
        };

        if (!options.noParseLine) {
            result.words = [];

            var ln = void 0; // Line number
            var cs = void 0; // Checksum
            var words = stripComments(line).match(re) || [];
            for (var i = 0; i < words.length; ++i) {
                var word = words[i];
                var letter = word[0].toUpperCase();
                var argument = word.slice(1);

                // $: Grbl-specific commands
                if (letter === '$') {
                    continue;
                }

                // N: Line number
                if (letter === 'N' && typeof ln === 'undefined') {
                    // Line (block) number in program
                    ln = Number(argument);
                    continue;
                }

                // *: Checksum
                if (letter === '*' && typeof cs === 'undefined') {
                    cs = Number(argument);
                    continue;
                }

                result.words.push([letter, Number(argument)]);
            }

            typeof ln !== 'undefined' && (result.ln = ln); // Line number
            typeof cs !== 'undefined' && (result.cs = cs); // Checksum
            if (result.cs && computeChecksum(line) !== result.cs) {
                result.err = true; // checksum failed
            }
        }

        return result;
    };
}();

// @param {object} stream The G-code line stream
// @param {options} options The options object
// @param {function} callback The callback function
var parseStream = function parseStream(stream, options) {
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    var emitter = new _events2.default.EventEmitter();

    try {
        (function () {
            var results = [];
            stream.pipe(new GCodeLineStream(options)).on('data', function (data) {
                emitter.emit('data', data);
                results.push(data);
            }).on('end', function () {
                emitter.emit('end', results);
                callback && callback(null, results);
            }).on('error', callback);
        })();
    } catch (err) {
        callback(err);
    }

    return emitter;
};

// @param {string} file The G-code path name
// @param {options} options The options object
// @param {function} callback The callback function
var parseFile = function parseFile(file, options) {
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if (typeof options === 'function') {
        callback = options;
        options = {};
    }
    file = file || '';
    var s = _fs2.default.createReadStream(file, { encoding: 'utf8' });
    s.on('error', callback);
    return parseStream(s, options, callback);
};

var parseFileSync = function parseFileSync(file, options) {
    return parseStringSync(_fs2.default.readFileSync(file, 'utf8'), options);
};

// @param {string} str The G-code text string
// @param {options} options The options object
// @param {function} callback The callback function
var parseString = function parseString(str, options) {
    var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;

    if (typeof options === 'function') {
        callback = options;
        options = {};
    }
    return parseStream(streamify(str), options, callback);
};

var parseStringSync = function parseStringSync(str, options) {
    var _options = _extends({}, options),
        _options$noParseLine = _options.noParseLine,
        noParseLine = _options$noParseLine === undefined ? false : _options$noParseLine;

    var results = [];
    var lines = str.split('\n');

    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i].trim();
        if (line.length === 0) {
            continue;
        }
        var result = parseLine(line, { noParseLine: noParseLine });
        results.push(result);
    }

    return results;
};

// @param {string} str The G-code text string
// @param {options} options The options object


var GCodeLineStream = function (_Transform) {
    _inherits(GCodeLineStream, _Transform);

    // @param {object} [options] The options object
    // @param {number} [options.batchSize] The batch size.
    // @param {boolean} [options.noParseLine] True to not parse line, false otherwise.
    function GCodeLineStream() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, GCodeLineStream);

        var _this = _possibleConstructorReturn(this, (GCodeLineStream.__proto__ || Object.getPrototypeOf(GCodeLineStream)).call(this, { objectMode: true }));

        _this.state = {
            lineCount: 0,
            lastChunkEndedWithCR: false
        };
        _this.options = {
            batchSize: 1000,
            noParseLine: false
        };
        _this.lineBuffer = '';
        _this.re = new RegExp(/.*(?:\r\n|\r|\n)|.+$/g);


        _this.options = _extends({}, _this.options, options);
        return _this;
    }

    _createClass(GCodeLineStream, [{
        key: '_transform',
        value: function _transform(chunk, encoding, next) {
            var _this2 = this;

            // decode binary chunks as UTF-8
            encoding = encoding || 'utf8';

            if (Buffer.isBuffer(chunk)) {
                if (encoding === 'buffer') {
                    encoding = 'utf8';
                }
                chunk = chunk.toString(encoding);
            }

            this.lineBuffer += chunk;

            if (!containsLineEnd(chunk)) {
                next();
                return;
            }

            var lines = this.lineBuffer.match(this.re);
            if (!lines || lines.length === 0) {
                next();
                return;
            }

            // Do not split CRLF which spans chunks
            if (this.state.lastChunkEndedWithCR && lines[0] === '\n') {
                lines.shift();
            }

            this.state.lastChunkEndedWithCR = this.lineBuffer[this.lineBuffer.length - 1] === '\r';

            if (this.lineBuffer[this.lineBuffer.length - 1] === '\r' || this.lineBuffer[this.lineBuffer.length - 1] === '\n') {
                this.lineBuffer = '';
            } else {
                var line = lines.pop() || '';
                this.lineBuffer = line;
            }

            iterateArray(lines, { batchSize: this.options.batchSize }, function (line, key) {
                line = line.trim();
                if (line.length > 0) {
                    var result = parseLine(line, {
                        noParseLine: _this2.options.noParseLine
                    });
                    _this2.push(result);
                }
            }, next);
        }
    }, {
        key: '_flush',
        value: function _flush(done) {
            if (this.lineBuffer) {
                var line = this.lineBuffer.trim();
                if (line.length > 0) {
                    var result = parseLine(line, {
                        noParseLine: this.options.noParseLine
                    });
                    this.push(result);
                }

                this.lineBuffer = '';
                this.state.lastChunkEndedWithCR = false;
            }

            done();
        }
    }]);

    return GCodeLineStream;
}(_stream.Transform);

exports.GCodeLineStream = GCodeLineStream;
exports.parseLine = parseLine;
exports.parseStream = parseStream;
exports.parseFile = parseFile;
exports.parseFileSync = parseFileSync;
exports.parseString = parseString;
exports.parseStringSync = parseStringSync;